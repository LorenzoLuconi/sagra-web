/**
 * Generated by @openapi-codegen
 *
 * @version v0
 */
import * as reactQuery from "@tanstack/react-query";
import { useSagraContext, SagraContext, queryKeyFn } from "./sagraContext";
import { deepMerge } from "./sagraUtils";
import type * as Fetcher from "./sagraFetcher";
import { sagraFetch } from "./sagraFetcher";
import type * as Schemas from "./sagraSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type ProductByIdPathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type ProductByIdVariables = {
  pathParams: ProductByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchProductById = (
  variables: ProductByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductByIdError,
    undefined,
    {},
    {},
    ProductByIdPathParams
  >({ url: "/v1/products/{productId}", method: "get", ...variables, signal });

export function productByIdQuery(variables: ProductByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Product>;
};

export function productByIdQuery(
  variables: ProductByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Product>)
    | reactQuery.SkipToken;
};

export function productByIdQuery(
  variables: ProductByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/products/{productId}",
      operationId: "productById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchProductById(variables, signal),
  };
}

export const useSuspenseProductById = <TData = Schemas.Product,>(
  variables: ProductByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Product, ProductByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Product, ProductByIdError, TData>({
    ...productByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useProductById = <TData = Schemas.Product,>(
  variables: ProductByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Product, ProductByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Product, ProductByIdError, TData>({
    ...productByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ProductUpdatePathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type ProductUpdateVariables = {
  body: Schemas.ProductRequest;
  pathParams: ProductUpdatePathParams;
} & SagraContext["fetcherOptions"];

export const fetchProductUpdate = (
  variables: ProductUpdateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductUpdateError,
    Schemas.ProductRequest,
    {},
    {},
    ProductUpdatePathParams
  >({ url: "/v1/products/{productId}", method: "put", ...variables, signal });

export const useProductUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductUpdateError,
      ProductUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductUpdateError,
    ProductUpdateVariables
  >({
    mutationFn: (variables: ProductUpdateVariables) =>
      fetchProductUpdate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductDeletePathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type ProductDeleteVariables = {
  pathParams: ProductDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchProductDelete = (
  variables: ProductDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    ProductDeleteError,
    undefined,
    {},
    {},
    ProductDeletePathParams
  >({
    url: "/v1/products/{productId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useProductDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ProductDeleteError,
      ProductDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    ProductDeleteError,
    ProductDeleteVariables
  >({
    mutationFn: (variables: ProductDeleteVariables) =>
      fetchProductDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductUpdateQuantityPathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductUpdateQuantityError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 450;
      payload: Schemas.ErrorResource;
    }
>;

export type ProductUpdateQuantityVariables = {
  body: Schemas.ProductQuantityUpdate;
  pathParams: ProductUpdateQuantityPathParams;
} & SagraContext["fetcherOptions"];

/**
 * Varia la quantità iniziale e disponibile di un prodotto con la variazione (positiva o negativa").
 * Esempio: -10 o 10 per diminuire o aumentare la quantità.
 *
 * In caso di diminuzione (valore negativo) se la quantità non è sufficiente da errore (codice 450)
 */
export const fetchProductUpdateQuantity = (
  variables: ProductUpdateQuantityVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductUpdateQuantityError,
    Schemas.ProductQuantityUpdate,
    {},
    {},
    ProductUpdateQuantityPathParams
  >({
    url: "/v1/products/{productId}/updateQuantity",
    method: "put",
    ...variables,
    signal,
  });

/**
 * Varia la quantità iniziale e disponibile di un prodotto con la variazione (positiva o negativa").
 * Esempio: -10 o 10 per diminuire o aumentare la quantità.
 *
 * In caso di diminuzione (valore negativo) se la quantità non è sufficiente da errore (codice 450)
 */
export const useProductUpdateQuantity = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductUpdateQuantityError,
      ProductUpdateQuantityVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductUpdateQuantityError,
    ProductUpdateQuantityVariables
  >({
    mutationFn: (variables: ProductUpdateQuantityVariables) =>
      fetchProductUpdateQuantity(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductSellUnlockPathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductSellUnlockError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type ProductSellUnlockVariables = {
  pathParams: ProductSellUnlockPathParams;
} & SagraContext["fetcherOptions"];

export const fetchProductSellUnlock = (
  variables: ProductSellUnlockVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductSellUnlockError,
    undefined,
    {},
    {},
    ProductSellUnlockPathParams
  >({
    url: "/v1/products/{productId}/sellUnlock",
    method: "put",
    ...variables,
    signal,
  });

export const useProductSellUnlock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductSellUnlockError,
      ProductSellUnlockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductSellUnlockError,
    ProductSellUnlockVariables
  >({
    mutationFn: (variables: ProductSellUnlockVariables) =>
      fetchProductSellUnlock(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductSellLockPathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductSellLockError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type ProductSellLockVariables = {
  pathParams: ProductSellLockPathParams;
} & SagraContext["fetcherOptions"];

export const fetchProductSellLock = (
  variables: ProductSellLockVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductSellLockError,
    undefined,
    {},
    {},
    ProductSellLockPathParams
  >({
    url: "/v1/products/{productId}/sellLock",
    method: "put",
    ...variables,
    signal,
  });

export const useProductSellLock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductSellLockError,
      ProductSellLockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductSellLockError,
    ProductSellLockVariables
  >({
    mutationFn: (variables: ProductSellLockVariables) =>
      fetchProductSellLock(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductInitQuantityPathParams = {
  /**
   * @format int64
   */
  productId: number;
};

export type ProductInitQuantityError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type ProductInitQuantityVariables = {
  body: Schemas.ProductQuantityUpdate;
  pathParams: ProductInitQuantityPathParams;
} & SagraContext["fetcherOptions"];

/**
 * Modifica la quantità iniziale del prodotto (inizializzazione giornaliera), impostando il valore passato che deve essere >= 0.
 * Viene sovrascritta la quantità disponibile e quella iniziale.
 *
 * Se ci sono degli ordini già effettuati in data odierna non è possibile effettuare l'inizializzazione (409)
 */
export const fetchProductInitQuantity = (
  variables: ProductInitQuantityVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductInitQuantityError,
    Schemas.ProductQuantityUpdate,
    {},
    {},
    ProductInitQuantityPathParams
  >({
    url: "/v1/products/{productId}/initQuantity",
    method: "put",
    ...variables,
    signal,
  });

/**
 * Modifica la quantità iniziale del prodotto (inizializzazione giornaliera), impostando il valore passato che deve essere >= 0.
 * Viene sovrascritta la quantità disponibile e quella iniziale.
 *
 * Se ci sono degli ordini già effettuati in data odierna non è possibile effettuare l'inizializzazione (409)
 */
export const useProductInitQuantity = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductInitQuantityError,
      ProductInitQuantityVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductInitQuantityError,
    ProductInitQuantityVariables
  >({
    mutationFn: (variables: ProductInitQuantityVariables) =>
      fetchProductInitQuantity(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type OrderByIdPathParams = {
  /**
   * @format int64
   */
  orderId: number;
};

export type OrderByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type OrderByIdVariables = {
  pathParams: OrderByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchOrderById = (
  variables: OrderByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Order,
    OrderByIdError,
    undefined,
    {},
    {},
    OrderByIdPathParams
  >({ url: "/v1/orders/{orderId}", method: "get", ...variables, signal });

export function orderByIdQuery(variables: OrderByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Order>;
};

export function orderByIdQuery(
  variables: OrderByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Order>)
    | reactQuery.SkipToken;
};

export function orderByIdQuery(
  variables: OrderByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/orders/{orderId}",
      operationId: "orderById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchOrderById(variables, signal),
  };
}

export const useSuspenseOrderById = <TData = Schemas.Order,>(
  variables: OrderByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Order, OrderByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Order, OrderByIdError, TData>({
    ...orderByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useOrderById = <TData = Schemas.Order,>(
  variables: OrderByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Order, OrderByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Order, OrderByIdError, TData>({
    ...orderByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type OrderUpdatePathParams = {
  /**
   * @format int64
   */
  orderId: number;
};

export type OrderUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 450;
      payload: Schemas.ErrorResource;
    }
>;

export type OrderUpdateVariables = {
  body: Schemas.OrderRequest;
  pathParams: OrderUpdatePathParams;
} & SagraContext["fetcherOptions"];

export const fetchOrderUpdate = (
  variables: OrderUpdateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Order,
    OrderUpdateError,
    Schemas.OrderRequest,
    {},
    {},
    OrderUpdatePathParams
  >({ url: "/v1/orders/{orderId}", method: "put", ...variables, signal });

export const useOrderUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Order,
      OrderUpdateError,
      OrderUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Order,
    OrderUpdateError,
    OrderUpdateVariables
  >({
    mutationFn: (variables: OrderUpdateVariables) =>
      fetchOrderUpdate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type OrderDeletePathParams = {
  /**
   * @format int64
   */
  orderId: number;
};

export type OrderDeleteError = Fetcher.ErrorWrapper<undefined>;

export type OrderDeleteVariables = {
  pathParams: OrderDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchOrderDelete = (
  variables: OrderDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    OrderDeleteError,
    undefined,
    {},
    {},
    OrderDeletePathParams
  >({ url: "/v1/orders/{orderId}", method: "delete", ...variables, signal });

export const useOrderDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      OrderDeleteError,
      OrderDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    OrderDeleteError,
    OrderDeleteVariables
  >({
    mutationFn: (variables: OrderDeleteVariables) =>
      fetchOrderDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MonitorByIdPathParams = {
  /**
   * @format int64
   */
  monitorId: number;
};

export type MonitorByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type MonitorByIdVariables = {
  pathParams: MonitorByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchMonitorById = (
  variables: MonitorByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Monitor,
    MonitorByIdError,
    undefined,
    {},
    {},
    MonitorByIdPathParams
  >({ url: "/v1/monitors/{monitorId}", method: "get", ...variables, signal });

export function monitorByIdQuery(variables: MonitorByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Monitor>;
};

export function monitorByIdQuery(
  variables: MonitorByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Monitor>)
    | reactQuery.SkipToken;
};

export function monitorByIdQuery(
  variables: MonitorByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/monitors/{monitorId}",
      operationId: "monitorById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMonitorById(variables, signal),
  };
}

export const useSuspenseMonitorById = <TData = Schemas.Monitor,>(
  variables: MonitorByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Monitor, MonitorByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Monitor, MonitorByIdError, TData>({
    ...monitorByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMonitorById = <TData = Schemas.Monitor,>(
  variables: MonitorByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Monitor, MonitorByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Monitor, MonitorByIdError, TData>({
    ...monitorByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateMonitorPathParams = {
  /**
   * @format int64
   */
  monitorId: number;
};

export type UpdateMonitorError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type UpdateMonitorVariables = {
  body: Schemas.Monitor;
  pathParams: UpdateMonitorPathParams;
} & SagraContext["fetcherOptions"];

export const fetchUpdateMonitor = (
  variables: UpdateMonitorVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Monitor,
    UpdateMonitorError,
    Schemas.Monitor,
    {},
    {},
    UpdateMonitorPathParams
  >({ url: "/v1/monitors/{monitorId}", method: "put", ...variables, signal });

export const useUpdateMonitor = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Monitor,
      UpdateMonitorError,
      UpdateMonitorVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Monitor,
    UpdateMonitorError,
    UpdateMonitorVariables
  >({
    mutationFn: (variables: UpdateMonitorVariables) =>
      fetchUpdateMonitor(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MonitorDeletePathParams = {
  /**
   * @format int64
   */
  monitorId: number;
};

export type MonitorDeleteError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type MonitorDeleteVariables = {
  pathParams: MonitorDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchMonitorDelete = (
  variables: MonitorDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    MonitorDeleteError,
    undefined,
    {},
    {},
    MonitorDeletePathParams
  >({
    url: "/v1/monitors/{monitorId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useMonitorDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MonitorDeleteError,
      MonitorDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    MonitorDeleteError,
    MonitorDeleteVariables
  >({
    mutationFn: (variables: MonitorDeleteVariables) =>
      fetchMonitorDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DiscountByIdPathParams = {
  /**
   * @format int64
   */
  discountId: number;
};

export type DiscountByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type DiscountByIdVariables = {
  pathParams: DiscountByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchDiscountById = (
  variables: DiscountByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Discount,
    DiscountByIdError,
    undefined,
    {},
    {},
    DiscountByIdPathParams
  >({ url: "/v1/discounts/{discountId}", method: "get", ...variables, signal });

export function discountByIdQuery(variables: DiscountByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Discount>;
};

export function discountByIdQuery(
  variables: DiscountByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Discount>)
    | reactQuery.SkipToken;
};

export function discountByIdQuery(
  variables: DiscountByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/discounts/{discountId}",
      operationId: "discountById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchDiscountById(variables, signal),
  };
}

export const useSuspenseDiscountById = <TData = Schemas.Discount,>(
  variables: DiscountByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Discount, DiscountByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.Discount,
    DiscountByIdError,
    TData
  >({
    ...discountByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDiscountById = <TData = Schemas.Discount,>(
  variables: DiscountByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Discount, DiscountByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Discount, DiscountByIdError, TData>({
    ...discountByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateDiscountPathParams = {
  /**
   * @format int64
   */
  discountId: number;
};

export type UpdateDiscountError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type UpdateDiscountVariables = {
  body: Schemas.DiscountRequest;
  pathParams: UpdateDiscountPathParams;
} & SagraContext["fetcherOptions"];

export const fetchUpdateDiscount = (
  variables: UpdateDiscountVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Discount,
    UpdateDiscountError,
    Schemas.DiscountRequest,
    {},
    {},
    UpdateDiscountPathParams
  >({ url: "/v1/discounts/{discountId}", method: "put", ...variables, signal });

export const useUpdateDiscount = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Discount,
      UpdateDiscountError,
      UpdateDiscountVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Discount,
    UpdateDiscountError,
    UpdateDiscountVariables
  >({
    mutationFn: (variables: UpdateDiscountVariables) =>
      fetchUpdateDiscount(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DepartmentByIdPathParams = {
  /**
   * @format int64
   */
  departmentId: number;
};

export type DepartmentByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type DepartmentByIdVariables = {
  pathParams: DepartmentByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchDepartmentById = (
  variables: DepartmentByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Department,
    DepartmentByIdError,
    undefined,
    {},
    {},
    DepartmentByIdPathParams
  >({
    url: "/v1/departments/{departmentId}",
    method: "get",
    ...variables,
    signal,
  });

export function departmentByIdQuery(variables: DepartmentByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Department>;
};

export function departmentByIdQuery(
  variables: DepartmentByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Department>)
    | reactQuery.SkipToken;
};

export function departmentByIdQuery(
  variables: DepartmentByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/departments/{departmentId}",
      operationId: "departmentById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDepartmentById(variables, signal),
  };
}

export const useSuspenseDepartmentById = <TData = Schemas.Department,>(
  variables: DepartmentByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Department, DepartmentByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.Department,
    DepartmentByIdError,
    TData
  >({
    ...departmentByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDepartmentById = <TData = Schemas.Department,>(
  variables: DepartmentByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Department, DepartmentByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Department, DepartmentByIdError, TData>({
    ...departmentByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DepartmentUpdatePathParams = {
  /**
   * @format int64
   */
  departmentId: number;
};

export type DepartmentUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type DepartmentUpdateVariables = {
  body: Schemas.DepartmentRequest;
  pathParams: DepartmentUpdatePathParams;
} & SagraContext["fetcherOptions"];

export const fetchDepartmentUpdate = (
  variables: DepartmentUpdateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Department,
    DepartmentUpdateError,
    Schemas.DepartmentRequest,
    {},
    {},
    DepartmentUpdatePathParams
  >({
    url: "/v1/departments/{departmentId}",
    method: "put",
    ...variables,
    signal,
  });

export const useDepartmentUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Department,
      DepartmentUpdateError,
      DepartmentUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Department,
    DepartmentUpdateError,
    DepartmentUpdateVariables
  >({
    mutationFn: (variables: DepartmentUpdateVariables) =>
      fetchDepartmentUpdate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DepartmentDeletePathParams = {
  /**
   * @format int64
   */
  departmentId: number;
};

export type DepartmentDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type DepartmentDeleteVariables = {
  pathParams: DepartmentDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchDepartmentDelete = (
  variables: DepartmentDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    DepartmentDeleteError,
    undefined,
    {},
    {},
    DepartmentDeletePathParams
  >({
    url: "/v1/departments/{departmentId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDepartmentDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DepartmentDeleteError,
      DepartmentDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    DepartmentDeleteError,
    DepartmentDeleteVariables
  >({
    mutationFn: (variables: DepartmentDeleteVariables) =>
      fetchDepartmentDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CourseByIdPathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type CourseByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type CourseByIdVariables = {
  pathParams: CourseByIdPathParams;
} & SagraContext["fetcherOptions"];

export const fetchCourseById = (
  variables: CourseByIdVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Course,
    CourseByIdError,
    undefined,
    {},
    {},
    CourseByIdPathParams
  >({ url: "/v1/courses/{id}", method: "get", ...variables, signal });

export function courseByIdQuery(variables: CourseByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Course>;
};

export function courseByIdQuery(
  variables: CourseByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Course>)
    | reactQuery.SkipToken;
};

export function courseByIdQuery(
  variables: CourseByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/courses/{id}",
      operationId: "courseById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchCourseById(variables, signal),
  };
}

export const useSuspenseCourseById = <TData = Schemas.Course,>(
  variables: CourseByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Course, CourseByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Course, CourseByIdError, TData>({
    ...courseByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useCourseById = <TData = Schemas.Course,>(
  variables: CourseByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Course, CourseByIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Course, CourseByIdError, TData>({
    ...courseByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CourseUpdatePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type CourseUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type CourseUpdateVariables = {
  body: Schemas.CourseRequest;
  pathParams: CourseUpdatePathParams;
} & SagraContext["fetcherOptions"];

export const fetchCourseUpdate = (
  variables: CourseUpdateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Course,
    CourseUpdateError,
    Schemas.CourseRequest,
    {},
    {},
    CourseUpdatePathParams
  >({ url: "/v1/courses/{id}", method: "put", ...variables, signal });

export const useCourseUpdate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Course,
      CourseUpdateError,
      CourseUpdateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Course,
    CourseUpdateError,
    CourseUpdateVariables
  >({
    mutationFn: (variables: CourseUpdateVariables) =>
      fetchCourseUpdate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CourseDeletePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type CourseDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 404;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type CourseDeleteVariables = {
  pathParams: CourseDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchCourseDelete = (
  variables: CourseDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    CourseDeleteError,
    undefined,
    {},
    {},
    CourseDeletePathParams
  >({ url: "/v1/courses/{id}", method: "delete", ...variables, signal });

export const useCourseDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      CourseDeleteError,
      CourseDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    CourseDeleteError,
    CourseDeleteVariables
  >({
    mutationFn: (variables: CourseDeleteVariables) =>
      fetchCourseDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProductsSearchQueryParams = {
  /**
   * @format int64
   */
  courseId?: number;
  /**
   * @format int64
   */
  departmentId?: number;
  excludeLinked?: boolean;
  /**
   * Ricerca con operatore 'contains'
   */
  name?: string;
};

export type ProductsSearchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type ProductsSearchResponse = Schemas.Product[];

export type ProductsSearchVariables = {
  queryParams?: ProductsSearchQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchProductsSearch = (
  variables: ProductsSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    ProductsSearchResponse,
    ProductsSearchError,
    undefined,
    {},
    ProductsSearchQueryParams,
    {}
  >({ url: "/v1/products", method: "get", ...variables, signal });

export function productsSearchQuery(variables: ProductsSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ProductsSearchResponse>;
};

export function productsSearchQuery(
  variables: ProductsSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ProductsSearchResponse>)
    | reactQuery.SkipToken;
};

export function productsSearchQuery(
  variables: ProductsSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/products",
      operationId: "productsSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchProductsSearch(variables, signal),
  };
}

export const useSuspenseProductsSearch = <TData = ProductsSearchResponse,>(
  variables: ProductsSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ProductsSearchResponse,
      ProductsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    ProductsSearchResponse,
    ProductsSearchError,
    TData
  >({
    ...productsSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useProductsSearch = <TData = ProductsSearchResponse,>(
  variables: ProductsSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ProductsSearchResponse,
      ProductsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<
    ProductsSearchResponse,
    ProductsSearchError,
    TData
  >({
    ...productsSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ProductCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type ProductCreateVariables = {
  body: Schemas.ProductRequest;
} & SagraContext["fetcherOptions"];

export const fetchProductCreate = (
  variables: ProductCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Product,
    ProductCreateError,
    Schemas.ProductRequest,
    {},
    {},
    {}
  >({ url: "/v1/products", method: "post", ...variables, signal });

export const useProductCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Product,
      ProductCreateError,
      ProductCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Product,
    ProductCreateError,
    ProductCreateVariables
  >({
    mutationFn: (variables: ProductCreateVariables) =>
      fetchProductCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type OrdersSearchQueryParams = {
  /**
   * Ricerca con operatore 'contains'
   */
  customer?: string;
  username?: string;
  /**
   * @format date
   */
  created?: string;
  /**
   * Zero-based page index (0..N)
   *
   * @default 0
   * @minimum 0
   */
  page?: number;
  /**
   * The size of the page to be returned
   *
   * @default 20
   * @minimum 1
   */
  size?: number;
  /**
   * Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   */
  sort?: string[];
};

export type OrdersSearchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type OrdersSearchResponse = Schemas.Order[];

export type OrdersSearchVariables = {
  queryParams?: OrdersSearchQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchOrdersSearch = (
  variables: OrdersSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    OrdersSearchResponse,
    OrdersSearchError,
    undefined,
    {},
    OrdersSearchQueryParams,
    {}
  >({ url: "/v1/orders", method: "get", ...variables, signal });

export function ordersSearchQuery(variables: OrdersSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<OrdersSearchResponse>;
};

export function ordersSearchQuery(
  variables: OrdersSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<OrdersSearchResponse>)
    | reactQuery.SkipToken;
};

export function ordersSearchQuery(
  variables: OrdersSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/orders",
      operationId: "ordersSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchOrdersSearch(variables, signal),
  };
}

export const useSuspenseOrdersSearch = <TData = OrdersSearchResponse,>(
  variables: OrdersSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<OrdersSearchResponse, OrdersSearchError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    OrdersSearchResponse,
    OrdersSearchError,
    TData
  >({
    ...ordersSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useOrdersSearch = <TData = OrdersSearchResponse,>(
  variables: OrdersSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<OrdersSearchResponse, OrdersSearchError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<OrdersSearchResponse, OrdersSearchError, TData>({
    ...ordersSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type OrderCreateError = Fetcher.ErrorWrapper<{
  status: 450;
  payload: Schemas.ErrorResource;
}>;

export type OrderCreateVariables = {
  body: Schemas.OrderRequest;
} & SagraContext["fetcherOptions"];

export const fetchOrderCreate = (
  variables: OrderCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<Schemas.Order, OrderCreateError, Schemas.OrderRequest, {}, {}, {}>(
    { url: "/v1/orders", method: "post", ...variables, signal },
  );

export const useOrderCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Order,
      OrderCreateError,
      OrderCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Order,
    OrderCreateError,
    OrderCreateVariables
  >({
    mutationFn: (variables: OrderCreateVariables) =>
      fetchOrderCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MonitorSearchError = Fetcher.ErrorWrapper<undefined>;

export type MonitorSearchResponse = Schemas.Monitor[];

export type MonitorSearchVariables = SagraContext["fetcherOptions"];

export const fetchMonitorSearch = (
  variables: MonitorSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<MonitorSearchResponse, MonitorSearchError, undefined, {}, {}, {}>({
    url: "/v1/monitors",
    method: "get",
    ...variables,
    signal,
  });

export function monitorSearchQuery(variables: MonitorSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MonitorSearchResponse>;
};

export function monitorSearchQuery(
  variables: MonitorSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MonitorSearchResponse>)
    | reactQuery.SkipToken;
};

export function monitorSearchQuery(
  variables: MonitorSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/monitors",
      operationId: "monitorSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMonitorSearch(variables, signal),
  };
}

export const useSuspenseMonitorSearch = <TData = MonitorSearchResponse,>(
  variables: MonitorSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MonitorSearchResponse,
      MonitorSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    MonitorSearchResponse,
    MonitorSearchError,
    TData
  >({
    ...monitorSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMonitorSearch = <TData = MonitorSearchResponse,>(
  variables: MonitorSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MonitorSearchResponse,
      MonitorSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<MonitorSearchResponse, MonitorSearchError, TData>({
    ...monitorSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MonitorCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type MonitorCreateVariables = {
  body: Schemas.Monitor;
} & SagraContext["fetcherOptions"];

export const fetchMonitorCreate = (
  variables: MonitorCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<Schemas.Monitor, MonitorCreateError, Schemas.Monitor, {}, {}, {}>({
    url: "/v1/monitors",
    method: "post",
    ...variables,
    signal,
  });

export const useMonitorCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Monitor,
      MonitorCreateError,
      MonitorCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Monitor,
    MonitorCreateError,
    MonitorCreateVariables
  >({
    mutationFn: (variables: MonitorCreateVariables) =>
      fetchMonitorCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DiscountsSearchQueryParams = {
  /**
   * Ricerca del nome con operatore 'contains'
   */
  name?: string;
};

export type DiscountsSearchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type DiscountsSearchResponse = Schemas.Discount[];

export type DiscountsSearchVariables = {
  queryParams?: DiscountsSearchQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchDiscountsSearch = (
  variables: DiscountsSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    DiscountsSearchResponse,
    DiscountsSearchError,
    undefined,
    {},
    DiscountsSearchQueryParams,
    {}
  >({ url: "/v1/discounts", method: "get", ...variables, signal });

export function discountsSearchQuery(variables: DiscountsSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<DiscountsSearchResponse>;
};

export function discountsSearchQuery(
  variables: DiscountsSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<DiscountsSearchResponse>)
    | reactQuery.SkipToken;
};

export function discountsSearchQuery(
  variables: DiscountsSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/discounts",
      operationId: "discountsSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDiscountsSearch(variables, signal),
  };
}

export const useSuspenseDiscountsSearch = <TData = DiscountsSearchResponse,>(
  variables: DiscountsSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DiscountsSearchResponse,
      DiscountsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    DiscountsSearchResponse,
    DiscountsSearchError,
    TData
  >({
    ...discountsSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDiscountsSearch = <TData = DiscountsSearchResponse,>(
  variables: DiscountsSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DiscountsSearchResponse,
      DiscountsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<
    DiscountsSearchResponse,
    DiscountsSearchError,
    TData
  >({
    ...discountsSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DiscountCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type DiscountCreateVariables = {
  body: Schemas.DiscountRequest;
} & SagraContext["fetcherOptions"];

export const fetchDiscountCreate = (
  variables: DiscountCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Discount,
    DiscountCreateError,
    Schemas.DiscountRequest,
    {},
    {},
    {}
  >({ url: "/v1/discounts", method: "post", ...variables, signal });

export const useDiscountCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Discount,
      DiscountCreateError,
      DiscountCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Discount,
    DiscountCreateError,
    DiscountCreateVariables
  >({
    mutationFn: (variables: DiscountCreateVariables) =>
      fetchDiscountCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DepartmentsSearchQueryParams = {
  /**
   * Ricerca del nome con operatore 'contains'
   */
  name?: string;
};

export type DepartmentsSearchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type DepartmentsSearchResponse = Schemas.Department[];

export type DepartmentsSearchVariables = {
  queryParams?: DepartmentsSearchQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchDepartmentsSearch = (
  variables: DepartmentsSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    DepartmentsSearchResponse,
    DepartmentsSearchError,
    undefined,
    {},
    DepartmentsSearchQueryParams,
    {}
  >({ url: "/v1/departments", method: "get", ...variables, signal });

export function departmentsSearchQuery(variables: DepartmentsSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<DepartmentsSearchResponse>;
};

export function departmentsSearchQuery(
  variables: DepartmentsSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<DepartmentsSearchResponse>)
    | reactQuery.SkipToken;
};

export function departmentsSearchQuery(
  variables: DepartmentsSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/departments",
      operationId: "departmentsSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDepartmentsSearch(variables, signal),
  };
}

export const useSuspenseDepartmentsSearch = <
  TData = DepartmentsSearchResponse,
>(
  variables: DepartmentsSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DepartmentsSearchResponse,
      DepartmentsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    DepartmentsSearchResponse,
    DepartmentsSearchError,
    TData
  >({
    ...departmentsSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDepartmentsSearch = <TData = DepartmentsSearchResponse,>(
  variables: DepartmentsSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DepartmentsSearchResponse,
      DepartmentsSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<
    DepartmentsSearchResponse,
    DepartmentsSearchError,
    TData
  >({
    ...departmentsSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DepartmentCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type DepartmentCreateVariables = {
  body: Schemas.DepartmentRequest;
} & SagraContext["fetcherOptions"];

export const fetchDepartmentCreate = (
  variables: DepartmentCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Department,
    DepartmentCreateError,
    Schemas.DepartmentRequest,
    {},
    {},
    {}
  >({ url: "/v1/departments", method: "post", ...variables, signal });

export const useDepartmentCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Department,
      DepartmentCreateError,
      DepartmentCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Department,
    DepartmentCreateError,
    DepartmentCreateVariables
  >({
    mutationFn: (variables: DepartmentCreateVariables) =>
      fetchDepartmentCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CoursesSearchQueryParams = {
  /**
   * Ricerca del nome con operatore 'contains'
   */
  name?: string;
};

export type CoursesSearchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type CoursesSearchResponse = Schemas.Course[];

export type CoursesSearchVariables = {
  queryParams?: CoursesSearchQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchCoursesSearch = (
  variables: CoursesSearchVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    CoursesSearchResponse,
    CoursesSearchError,
    undefined,
    {},
    CoursesSearchQueryParams,
    {}
  >({ url: "/v1/courses", method: "get", ...variables, signal });

export function coursesSearchQuery(variables: CoursesSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<CoursesSearchResponse>;
};

export function coursesSearchQuery(
  variables: CoursesSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<CoursesSearchResponse>)
    | reactQuery.SkipToken;
};

export function coursesSearchQuery(
  variables: CoursesSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/courses",
      operationId: "coursesSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchCoursesSearch(variables, signal),
  };
}

export const useSuspenseCoursesSearch = <TData = CoursesSearchResponse,>(
  variables: CoursesSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CoursesSearchResponse,
      CoursesSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    CoursesSearchResponse,
    CoursesSearchError,
    TData
  >({
    ...coursesSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useCoursesSearch = <TData = CoursesSearchResponse,>(
  variables: CoursesSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CoursesSearchResponse,
      CoursesSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<CoursesSearchResponse, CoursesSearchError, TData>({
    ...coursesSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CourseCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ErrorResource;
    }
  | {
      status: 409;
      payload: Schemas.ErrorResource;
    }
>;

export type CourseCreateVariables = {
  body: Schemas.CourseRequest;
} & SagraContext["fetcherOptions"];

export const fetchCourseCreate = (
  variables: CourseCreateVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Course,
    CourseCreateError,
    Schemas.CourseRequest,
    {},
    {},
    {}
  >({ url: "/v1/courses", method: "post", ...variables, signal });

export const useCourseCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Course,
      CourseCreateError,
      CourseCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    Schemas.Course,
    CourseCreateError,
    CourseCreateVariables
  >({
    mutationFn: (variables: CourseCreateVariables) =>
      fetchCourseCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type OrdersCountQueryParams = {
  /**
   * Ricerca con operatore 'contains'
   */
  customer?: string;
  username?: string;
  /**
   * @format date
   */
  created?: string;
};

export type OrdersCountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ErrorResource;
}>;

export type OrdersCountVariables = {
  queryParams?: OrdersCountQueryParams;
} & SagraContext["fetcherOptions"];

export const fetchOrdersCount = (
  variables: OrdersCountVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.Count,
    OrdersCountError,
    undefined,
    {},
    OrdersCountQueryParams,
    {}
  >({ url: "/v1/orders/count", method: "get", ...variables, signal });

export function ordersCountQuery(variables: OrdersCountVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Count>;
};

export function ordersCountQuery(
  variables: OrdersCountVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Count>)
    | reactQuery.SkipToken;
};

export function ordersCountQuery(
  variables: OrdersCountVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/orders/count",
      operationId: "ordersCount",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchOrdersCount(variables, signal),
  };
}

export const useSuspenseOrdersCount = <TData = Schemas.Count,>(
  variables: OrdersCountVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Count, OrdersCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Count, OrdersCountError, TData>({
    ...ordersCountQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useOrdersCount = <TData = Schemas.Count,>(
  variables: OrdersCountVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Count, OrdersCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.Count, OrdersCountError, TData>({
    ...ordersCountQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MonitorViewPathParams = {
  /**
   * @format int64
   */
  monitorId: number;
};

export type MonitorViewError = Fetcher.ErrorWrapper<undefined>;

export type MonitorViewVariables = {
  pathParams: MonitorViewPathParams;
} & SagraContext["fetcherOptions"];

export const fetchMonitorView = (
  variables: MonitorViewVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    Schemas.MonitorView,
    MonitorViewError,
    undefined,
    {},
    {},
    MonitorViewPathParams
  >({
    url: "/v1/monitors/{monitorId}/view",
    method: "get",
    ...variables,
    signal,
  });

export function monitorViewQuery(variables: MonitorViewVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.MonitorView>;
};

export function monitorViewQuery(
  variables: MonitorViewVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.MonitorView>)
    | reactQuery.SkipToken;
};

export function monitorViewQuery(
  variables: MonitorViewVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/v1/monitors/{monitorId}/view",
      operationId: "monitorView",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMonitorView(variables, signal),
  };
}

export const useSuspenseMonitorView = <TData = Schemas.MonitorView,>(
  variables: MonitorViewVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.MonitorView, MonitorViewError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.MonitorView,
    MonitorViewError,
    TData
  >({
    ...monitorViewQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMonitorView = <TData = Schemas.MonitorView,>(
  variables: MonitorViewVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.MonitorView, MonitorViewError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useSagraContext(options);
  return reactQuery.useQuery<Schemas.MonitorView, MonitorViewError, TData>({
    ...monitorViewQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DiscountDeletePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type DiscountDeleteError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: Schemas.ErrorResource;
}>;

export type DiscountDeleteVariables = {
  pathParams: DiscountDeletePathParams;
} & SagraContext["fetcherOptions"];

export const fetchDiscountDelete = (
  variables: DiscountDeleteVariables,
  signal?: AbortSignal,
) =>
  sagraFetch<
    undefined,
    DiscountDeleteError,
    undefined,
    {},
    {},
    DiscountDeletePathParams
  >({ url: "/v1/discounts/{id}", method: "delete", ...variables, signal });

export const useDiscountDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DiscountDeleteError,
      DiscountDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSagraContext();
  return reactQuery.useMutation<
    undefined,
    DiscountDeleteError,
    DiscountDeleteVariables
  >({
    mutationFn: (variables: DiscountDeleteVariables) =>
      fetchDiscountDelete(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/v1/products/{productId}";
      operationId: "productById";
      variables: ProductByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/orders/{orderId}";
      operationId: "orderById";
      variables: OrderByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/monitors/{monitorId}";
      operationId: "monitorById";
      variables: MonitorByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/discounts/{discountId}";
      operationId: "discountById";
      variables: DiscountByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/departments/{departmentId}";
      operationId: "departmentById";
      variables: DepartmentByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/courses/{id}";
      operationId: "courseById";
      variables: CourseByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/products";
      operationId: "productsSearch";
      variables: ProductsSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/orders";
      operationId: "ordersSearch";
      variables: OrdersSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/monitors";
      operationId: "monitorSearch";
      variables: MonitorSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/discounts";
      operationId: "discountsSearch";
      variables: DiscountsSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/departments";
      operationId: "departmentsSearch";
      variables: DepartmentsSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/courses";
      operationId: "coursesSearch";
      variables: CoursesSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/orders/count";
      operationId: "ordersCount";
      variables: OrdersCountVariables | reactQuery.SkipToken;
    }
  | {
      path: "/v1/monitors/{monitorId}/view";
      operationId: "monitorView";
      variables: MonitorViewVariables | reactQuery.SkipToken;
    };
